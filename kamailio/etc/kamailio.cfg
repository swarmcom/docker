#!KAMAILIO

#include local params
import_file "kamailio-local.cfg"

# flags:
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#!define FLT_DLG 9
#!define FLT_DLGINFO 10

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########
local.uablock = "sipcli|scanner|VaxSIPUserAgent" desc "block User-agent"
#LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=no
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=4

disable_tcp=no
auto_aliases=no
enable_tls=no
tcp_connection_lifetime=3605

mpath="/home/user/kamailio/lib64/kamailio/modules"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

loadmodule "erlang.so"
loadmodule "auth.so"
loadmodule "dialog.so"
loadmodule "nathelper.so"
#loadmodule "rtpproxy.so"
#loadmodule "htable.so"
loadmodule "pike.so"

# ----- erlang params ------
modparam("erlang", "cookie", "ClueCon")
modparam("erlang", "erlang_nodename", "reach@reach.ezuce")
modparam("erlang", "cnode_alivename", "kamailio")
modparam("erlang", "cnode_host", "kamailio.ezuce")
# for rpc api
modparam("pv", "shvset", "my_node=s:kamailio@kamailio.ezuce")

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

modparam("pike", "sampling_time_unit", 10)
modparam("pike", "reqs_density_per_unit", 10)
modparam("pike", "remove_latency", 20)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "default_expires", 60)
modparam("registrar", "max_expires", 60)
modparam("registrar", "min_expires", 60)
modparam("registrar", "gruu_enabled", 0)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)

modparam("dialog", "enable_stats", 1)
modparam("dialog", "db_mode", 0)
modparam("dialog", "dlg_flag", FLT_DLG)

####### Routing Logic ########

route {
    # per request initial checks
    route(REQINIT);
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    if (is_method("INVITE")) {
        if ($rU==$null) {
            # request with no Username in RURI
            sl_send_reply("484","Address Incomplete");
            exit;
        }
        setflag(FLT_ACC); # do accounting
    }

    route(REACH);
}

# Just relay to host
route[RELAY] {
    if(is_method("INVITE|BYE|UPDATE|CANCEL|ACK")) {
        setflag(FLT_DLGINFO);
        dlg_manage();
    }
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    if($ua=~$sel(cfg_get.local.uablock)) {
        xlog("L_INFO", "drop for ua $ua from $si");
        exit;
    }
    if (!pike_check_req()) {
        xlog("L_INFO","ALERT: pike block $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }
    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if (is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        setbflag(FLB_NATSIPPING);
    }
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

route[LOCATION] {
    if (!lookup("location")) {
        sl_send_reply("404", "Not here");
        exit;
    }
    # when routing via usrloc, log the missed calls also
    if (is_method("INVITE")) {
        setflag(FLT_ACCMISSED);
    }
    route(RELAY);
    exit;
}

# Presence server route (drop)
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE")) {
        return;
    }
    sl_send_reply("404", "Not here");
    exit;
}

route[REACH] {
    if (is_method("REGISTER")) {
        $erl_list(auth) = $su;
        $erl_list(auth) = $fd;
        $erl_list(auth) = $fU;
        $erl_list(auth) = $expires(min);
        $erl_list(auth) = $Ri;
        erl_rpc("kamailio", "auth_register", "$erl_list(auth)", "$erl_xbuff(auth_reply)");
        if (!$erl_xbuff(auth_reply[0])) {
            auth_challenge("$fd", "1");
            exit;
        }
        if (!pv_auth_check("$fd", "$erl_xbuff(auth_reply[1])", "1", "1")) {
            auth_challenge("$fd", "1");
            exit;
        }
        route(REGISTRAR);
    }
    if (is_method("INVITE")) {
        $erl_list(auth) = $fd;
        $erl_list(auth) = $fU;
        $erl_list(auth) = $si;
        erl_rpc("kamailio", "auth_invite", "$erl_list(auth)", "$erl_xbuff(auth_reply)");
        switch($erl_xbuff(auth_reply[0])) {
            case 1:
                sl_send_reply("404","User not found");
                exit;
            case 2:
                if (!pv_auth_check("$fd", "$erl_xbuff(auth_reply[1])", "1", "1")) {
                    auth_challenge("$fd", "1");
                    exit;
                }
                consume_credentials();
                route(ROUTE);
                exit;
            case 3:
                route(ROUTE);
                exit;
            default:
                xlog("bad invite auth reply code $erl_xbuff(auth_reply[0])\n");
        }
    }
    return;
}

route[ROUTE] {
    $erl_list(req) = $rd;
    $erl_list(req) = $rU;
    $erl_list(req) = $fd;
    $erl_list(req) = $fU;
    $erl_list(req) = $si;
    erl_rpc("kamailio", "route_invite", "$erl_list(req)", "$erl_xbuff(reply)");
    switch($erl_xbuff(reply[0])) {
        case 4:
            sl_send_reply("488","No route");
            exit;
        case 5:
            route(LOCATION);
            break;
        case 6:
            $ru = "sip:" + $rU + "@" + $erl_xbuff(reply[1]);
            route(RELAY);
            break;
        case 7:
            route(SIPOUT);
            break;
        default:
            xlog("bad route invite reply code $erl_xbuff(reply[0])\n");
    }
}

route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# Routing to foreign domains
route[SIPOUT] {
    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}

event_route[usrloc:contact-expired] {
    $erl_list(expired) = $ulc(exp=>domain);
    $erl_list(expired) = $ulc(exp=>aor);
    erl_rpc("kamailio", "expired", "$erl_list(expired)", "$erl_xbuff(expired_reply)");
}

event_route[dialog:start] {
    $erl_list(dlg) = $dlg(to_uri);
    $erl_list(dlg) = $dlg(from_uri);
    $erl_list(dlg) = $dlg(callid);
    erl_rpc("kamailio", "dialog_start", "$erl_list(dlg)", "$erl_xbuff(dlg_reply)");
}

event_route[dialog:end] {
    $erl_list(dlg) = $dlg(to_uri);
    $erl_list(dlg) = $dlg(from_uri);
    $erl_list(dlg) = $dlg(callid);
    erl_rpc("kamailio", "dialog_end", "$erl_list(dlg)", "$erl_xbuff(dlg_reply)");
}

event_route[dialog:failed] {
    $erl_list(dlg) = $dlg(to_uri);
    $erl_list(dlg) = $dlg(from_uri);
    $erl_list(dlg) = $dlg(callid);
    erl_rpc("kamailio", "dialog_failed", "$erl_list(dlg)", "$erl_xbuff(dlg_reply)");
}

